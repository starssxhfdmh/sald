// Benchmark: Class Instantiation & Method Calls
// Tests: OOP performance, method dispatch

class Point {
    fun init(self, x, y) {
        self.x = x
        self.y = y
    }
    
    fun distance(self, other) {
        let dx = self.x - other.x
        let dy = self.y - other.y
        return Math.sqrt(dx * dx + dy * dy)
    }
    
    fun move(self, dx, dy) {
        self.x += dx
        self.y += dy
        return self
    }
    
    fun clone(self) {
        return Point(self.x, self.y)
    }
}

class Rectangle {
    fun init(self, x, y, width, height) {
        self.origin = Point(x, y)
        self.width = width
        self.height = height
    }
    
    fun area(self) {
        return self.width * self.height
    }
    
    fun perimeter(self) {
        return 2 * (self.width + self.height)
    }
    
    fun contains(self, point) {
        return point.x >= self.origin.x && 
               point.x <= self.origin.x + self.width &&
               point.y >= self.origin.y && 
               point.y <= self.origin.y + self.height
    }
}

let start = Timer.now()

// Create many objects
let points = []
let i = 0
while i < 10000 {
    points.push(Point(i, i * 2))
    i += 1
}

// Method calls
let total_distance = 0
i = 0
while i < points.length() - 1 {
    total_distance += points[i].distance(points[i + 1])
    i += 1
}

// Nested object creation
let rectangles = []
i = 0
while i < 1000 {
    rectangles.push(Rectangle(i, i, i + 10, i + 20))
    i += 1
}

// Method calls on nested objects
let total_area = 0
for rect in rectangles {
    total_area += rect.area()
}

let elapsed = Timer.now() - start

Console.println($"Points created: {points.length()}")
Console.println($"Total distance: {total_distance}")
Console.println($"Total area: {total_area}")
Console.println($"Time: {elapsed}ms")
